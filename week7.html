<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 7: 虛擬記憶體 - 作業系統課程</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            line-height: 1.8;
            color: #1a202c;
            background: #f7fafc;
        }

        .header {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            color: white;
            padding: 2rem 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .header .week-info {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .nav-bar {
            background: white;
            padding: 1rem 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .nav-links {
            display: flex;
            gap: 1rem;
            list-style: none;
            flex-wrap: wrap;
        }

        .nav-links a {
            color: #4a5568;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            transition: all 0.2s;
            font-weight: 500;
        }

        .nav-links a:hover {
            background: #edf2f7;
            color: #1e40af;
        }

        .content {
            background: white;
            margin: 2rem auto;
            padding: 3rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        h2 {
            color: #2d3748;
            font-size: 1.875rem;
            margin: 2.5rem 0 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #1e40af;
        }

        h3 {
            color: #2d3748;
            font-size: 1.5rem;
            margin: 2rem 0 1rem;
        }

        h4 {
            color: #4a5568;
            font-size: 1.25rem;
            margin: 1.5rem 0 1rem;
        }

        p {
            margin-bottom: 1rem;
            color: #4a5568;
        }

        ul, ol {
            margin: 1rem 0 1rem 2rem;
            color: #4a5568;
        }

        li {
            margin-bottom: 0.75rem;
            line-height: 1.7;
        }

        .intro-box {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            padding: 2rem;
            border-radius: 0.5rem;
            margin: 2rem 0;
            border-left: 4px solid #1e40af;
        }

        .intro-box h3 {
            color: #1e3a8a;
            margin-top: 0;
        }

        .learning-objectives {
            background: #f0fdf4;
            padding: 1.5rem;
            border-radius: 0.5rem;
            border-left: 4px solid #10b981;
            margin: 1.5rem 0;
        }

        .learning-objectives h3 {
            color: #065f46;
            margin-top: 0;
        }

        .learning-objectives ul {
            margin-top: 1rem;
        }

        .learning-objectives li {
            color: #047857;
        }

        .concept-box {
            background: #fef3c7;
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #f59e0b;
        }

        .concept-box h4 {
            color: #92400e;
            margin-top: 0;
        }

        .note-box {
            background: #dbeafe;
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #2563eb;
        }

        .note-box strong {
            color: #1e40af;
        }

        .warning-box {
            background: #fee2e2;
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #dc2626;
        }

        .warning-box strong {
            color: #991b1b;
        }

        .code-block {
            margin: 2rem 0;
        }

        .code-header {
            background: #2d3748;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem 0.5rem 0 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .code-block pre {
            margin: 0;
            border-radius: 0 0 0.5rem 0.5rem;
            background: #f7fafc;
            border: 1px solid #e2e8f0;
        }

        .code-block code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
        }

        .output-block {
            background: #1a202c;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
        }

        .output-block .prompt {
            color: #48bb78;
        }

        .output-block .output {
            color: #90cdf4;
        }

        .page-diagram {
            background: #f8fafc;
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin: 1.5rem 0;
            border: 2px solid #e2e8f0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
        }

        .exercise-section {
            background: #fff7ed;
            padding: 2rem;
            border-radius: 0.5rem;
            margin: 2rem 0;
            border: 2px solid #fb923c;
        }

        .exercise-section h3 {
            color: #c2410c;
            margin-top: 0;
        }

        .exercise-item {
            background: white;
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 0.5rem;
            border-left: 4px solid #fb923c;
        }

        .exercise-item h4 {
            color: #ea580c;
            margin-top: 0;
        }

        .difficulty {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        .difficulty-easy {
            background: #d1fae5;
            color: #065f46;
        }

        .difficulty-medium {
            background: #fed7aa;
            color: #9a3412;
        }

        .difficulty-hard {
            background: #fecaca;
            color: #991b1b;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            background: white;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
            border: 1px solid #e2e8f0;
        }

        th {
            background: #edf2f7;
            color: #2d3748;
            font-weight: 600;
        }

        .quiz-section {
            background: #f0f9ff;
            padding: 2rem;
            border-radius: 0.5rem;
            margin: 2rem 0;
            border-left: 4px solid #0284c7;
        }

        .quiz-section h3 {
            color: #075985;
            margin-top: 0;
        }

        .quiz-question {
            background: white;
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 0.5rem;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 2px solid #e2e8f0;
        }

        .nav-button {
            padding: 0.75rem 2rem;
            background: #1e40af;
            color: white;
            text-decoration: none;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .nav-button:hover {
            background: #1e3a8a;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(30, 64, 175, 0.3);
        }

        .footer {
            text-align: center;
            padding: 2rem;
            color: #718096;
            margin-top: 3rem;
        }

        @media (max-width: 768px) {
            .content {
                padding: 1.5rem;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="container">
            <h1>Week 7: 虛擬記憶體</h1>
            <p class="week-info">Virtual Memory</p>
        </div>
    </div>

    <nav class="nav-bar">
        <div class="container">
            <ul class="nav-links">
                <li><a href="index.html">課程首頁</a></li>
                <li><a href="#introduction">課程介紹</a></li>
                <li><a href="#theory">理論學習</a></li>
                <li><a href="#practice">實作練習</a></li>
                <li><a href="#exercises">作業</a></li>
                <li><a href="#quiz">測驗</a></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <div class="content">
            
            <div class="intro-box" id="introduction">
                <h3>本週課程介紹</h3>
                <p>歡迎來到第七週的課程！虛擬記憶體是現代作業系統最重要的技術之一。它讓程式可以使用比實體記憶體更大的位址空間，並提供了行程之間的隔離和保護。</p>
                <p>本週我們將深入探討虛擬記憶體的實作機制，學習需求分頁（Demand Paging）、頁面置換演算法（Page Replacement Algorithms），以及如何處理顛簸（Thrashing）問題。這些知識對於理解現代作業系統如何高效管理記憶體至關重要。</p>
            </div>

            <div class="learning-objectives">
                <h3>學習目標</h3>
                <ul>
                    <li>理解虛擬記憶體的概念與優勢</li>
                    <li>掌握需求分頁的運作原理</li>
                    <li>學習各種頁面置換演算法（FIFO、LRU、Optimal）</li>
                    <li>了解 Belady's Anomaly 現象</li>
                    <li>認識工作集模型與顛簸問題</li>
                    <li>理解 TLB 的作用</li>
                </ul>
            </div>

            <section id="theory">
                <h2>一、虛擬記憶體基礎</h2>
                
                <h3>1.1 什麼是虛擬記憶體？</h3>
                <p>虛擬記憶體是一種記憶體管理技術，將次級儲存（如硬碟）的一部分作為主記憶體的延伸。程式可以使用比實體記憶體更大的位址空間。</p>

                <div class="concept-box">
                    <h4>虛擬記憶體的優勢</h4>
                    <ol>
                        <li><strong>程式大小不受限：</strong>程式可以大於實體記憶體</li>
                        <li><strong>更多並行：</strong>可以同時執行更多程式</li>
                        <li><strong>行程隔離：</strong>每個行程有獨立的位址空間</li>
                        <li><strong>記憶體保護：</strong>防止行程互相干擾</li>
                        <li><strong>共享記憶體：</strong>多個行程可以共享同一份資料</li>
                    </ol>
                </div>

                <h3>1.2 需求分頁（Demand Paging）</h3>
                <p>只有在需要時才將頁面載入記憶體，而不是在程式開始時就載入所有頁面。</p>

                <div class="concept-box">
                    <h4>需求分頁的運作</h4>
                    <ol>
                        <li>行程啟動時，不載入任何頁面</li>
                        <li>當存取某個頁面時：
                            <ul>
                                <li>如果頁面在記憶體中 → 直接存取（頁面命中）</li>
                                <li>如果頁面不在記憶體中 → 發生頁面錯誤（Page Fault）</li>
                            </ul>
                        </li>
                        <li>處理頁面錯誤：
                            <ul>
                                <li>找到空閒框架（或選擇一個頁面置換出去）</li>
                                <li>從磁碟讀取需要的頁面</li>
                                <li>更新頁表</li>
                                <li>重新執行導致錯誤的指令</li>
                            </ul>
                        </li>
                    </ol>
                </div>

                <h3>1.3 頁面錯誤處理</h3>

                <div class="page-diagram">
<strong>頁面錯誤處理流程：</strong>

1. CPU 存取頁面
   ↓
2. 檢查頁表的有效位元
   ↓
3. 有效？
   是 → 6. 正常存取記憶體
   否 ↓
4. 頁面錯誤中斷
   ↓
5. 作業系統處理：
   - 檢查頁面是否合法
   - 找到空閒框架
   - 從磁碟讀取頁面
   - 更新頁表
   ↓
6. 重新執行指令
                </div>

                <h2>二、頁面置換演算法</h2>

                <h3>2.1 為什麼需要頁面置換？</h3>
                <p>當發生頁面錯誤且沒有空閒框架時，必須選擇一個頁面換出到磁碟，為新頁面騰出空間。好的置換演算法可以減少頁面錯誤率。</p>

                <h3>2.2 FIFO（First-In-First-Out）</h3>
                <p>最簡單的演算法，置換最早進入記憶體的頁面。</p>

                <div class="concept-box">
                    <h4>FIFO 特性</h4>
                    <ul>
                        <li><strong>優點：</strong>簡單、易於實作</li>
                        <li><strong>缺點：</strong>可能置換掉經常使用的頁面</li>
                        <li><strong>Belady's Anomaly：</strong>增加框架數可能導致更多頁面錯誤</li>
                    </ul>
                </div>

                <h4>FIFO 範例</h4>
                <div class="page-diagram">
參考字串: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
框架數: 3

時間 → 7  0  1  2  0  3  0  4  2  3  0  3  2
框架1   7  7  7  2  2  2  2  4  4  4  0  0  0
框架2      0  0  0  0  3  3  3  2  2  2  3  3
框架3         1  1  1  1  0  0  0  3  3  3  2
錯誤    *  *  *  *     *  *  *  *  *  *     *

總頁面錯誤: 12 次
                </div>

                <h3>2.3 Optimal（最佳置換）</h3>
                <p>置換未來最長時間不會被使用的頁面。這是理論上的最佳演算法，但實際上無法實作（因為無法預知未來）。</p>

                <div class="concept-box">
                    <h4>Optimal 特性</h4>
                    <ul>
                        <li><strong>優點：</strong>保證最少的頁面錯誤</li>
                        <li><strong>缺點：</strong>需要知道未來的參考序列，無法實作</li>
                        <li><strong>用途：</strong>作為其他演算法的基準</li>
                    </ul>
                </div>

                <h3>2.4 LRU（Least Recently Used）</h3>
                <p>置換最長時間未被使用的頁面。基於局部性原理：最近使用的頁面很可能再被使用。</p>

                <div class="concept-box">
                    <h4>LRU 特性</h4>
                    <ul>
                        <li><strong>優點：</strong>效能接近 Optimal</li>
                        <li><strong>缺點：</strong>實作複雜、需要硬體支援</li>
                        <li><strong>實作方式：</strong>
                            <ul>
                                <li>計數器：每次存取時更新時間戳</li>
                                <li>堆疊：維護頁面使用順序</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <h3>2.5 LRU 近似演算法</h3>

                <h4>Second Chance（時鐘演算法）</h4>
                <p>使用參考位元（Reference Bit）改良的 FIFO。</p>
                <ul>
                    <li>每個頁面有一個參考位元</li>
                    <li>存取頁面時設定為 1</li>
                    <li>置換時：如果參考位元為 1，給予第二次機會（設為 0）；如果為 0，則置換</li>
                </ul>

                <h3>2.6 演算法比較</h3>

                <table>
                    <thead>
                        <tr>
                            <th>演算法</th>
                            <th>實作難度</th>
                            <th>效能</th>
                            <th>開銷</th>
                            <th>實用性</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>FIFO</td>
                            <td>簡單</td>
                            <td>差</td>
                            <td>低</td>
                            <td>適合簡單系統</td>
                        </tr>
                        <tr>
                            <td>Optimal</td>
                            <td>不可能</td>
                            <td>最佳</td>
                            <td>-</td>
                            <td>理論基準</td>
                        </tr>
                        <tr>
                            <td>LRU</td>
                            <td>複雜</td>
                            <td>很好</td>
                            <td>高</td>
                            <td>需硬體支援</td>
                        </tr>
                        <tr>
                            <td>Second Chance</td>
                            <td>中等</td>
                            <td>好</td>
                            <td>中</td>
                            <td>廣泛使用</td>
                        </tr>
                    </tbody>
                </table>

                <h2>三、效能優化</h2>

                <h3>3.1 TLB（Translation Lookaside Buffer）</h3>
                <p>TLB 是一個快速的硬體快取，儲存最近使用的頁表項目，加速位址轉換。</p>

                <div class="concept-box">
                    <h4>有效存取時間（Effective Access Time）</h4>
                    <p>假設：</p>
                    <ul>
                        <li>TLB 查詢時間 = 1 ns</li>
                        <li>記憶體存取時間 = 100 ns</li>
                        <li>TLB 命中率 = 80%</li>
                    </ul>
                    <p>計算：</p>
                    <ul>
                        <li>TLB 命中：1 + 100 = 101 ns</li>
                        <li>TLB 未命中：1 + 100 + 100 = 201 ns（需要額外存取頁表）</li>
                        <li>有效存取時間 = 0.8 × 101 + 0.2 × 201 = 121 ns</li>
                    </ul>
                </div>

                <h3>3.2 工作集模型（Working Set Model）</h3>
                <p>工作集是指在某個時間窗口內，行程實際使用的頁面集合。</p>

                <div class="note-box">
                    <strong>工作集原理：</strong>
                    <p>如果行程的工作集都在記憶體中，頁面錯誤率會很低。如果工作集太大，無法全部載入記憶體，就會頻繁發生頁面錯誤。</p>
                </div>

                <h3>3.3 顛簸（Thrashing）</h3>
                <p>當系統花費大部分時間在處理頁面錯誤，而不是執行有用的工作，就發生了顛簸。</p>

                <div class="warning-box">
                    <strong>顛簸的原因與解決</strong>
                    <p><strong>原因：</strong></p>
                    <ul>
                        <li>太多行程同時執行</li>
                        <li>每個行程分配的框架太少</li>
                        <li>工作集無法完全載入記憶體</li>
                    </ul>
                    <p><strong>解決方法：</strong></p>
                    <ul>
                        <li>減少多程式設計程度（暫停部分行程）</li>
                        <li>增加實體記憶體</li>
                        <li>使用工作集演算法</li>
                        <li>頁面錯誤頻率（PFF）控制</li>
                    </ul>
                </div>

            </section>

            <section id="practice">
                <h2>四、實作練習</h2>

                <h3>4.1 FIFO 頁面置換模擬</h3>

                <div class="code-block">
                    <div class="code-header">
                        <span>fifo_page_replacement.c</span>
                        <span>FIFO 頁面置換演算法</span>
                    </div>
                    <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define MAX_FRAMES 10
#define MAX_PAGES 100

bool is_page_in_frames(int frames[], int num_frames, int page) {
    for (int i = 0; i < num_frames; i++) {
        if (frames[i] == page) {
            return true;
        }
    }
    return false;
}

void print_frames(int frames[], int num_frames) {
    printf("[ ");
    for (int i = 0; i < num_frames; i++) {
        if (frames[i] == -1) {
            printf("- ");
        } else {
            printf("%d ", frames[i]);
        }
    }
    printf("]");
}

int fifo_page_replacement(int pages[], int num_pages, int num_frames) {
    int frames[MAX_FRAMES];
    int page_faults = 0;
    int next_frame = 0;
    
    // 初始化框架
    for (int i = 0; i < num_frames; i++) {
        frames[i] = -1;
    }
    
    printf("\n=== FIFO 頁面置換模擬 ===\n");
    printf("框架數: %d\n", num_frames);
    printf("參考字串: ");
    for (int i = 0; i < num_pages; i++) {
        printf("%d ", pages[i]);
    }
    printf("\n\n");
    
    printf("步驟\t頁面\t框架狀態\t\t結果\n");
    printf("----------------------------------------------------\n");
    
    for (int i = 0; i < num_pages; i++) {
        int page = pages[i];
        
        printf("%d\t%d\t", i + 1, page);
        
        if (!is_page_in_frames(frames, num_frames, page)) {
            // 頁面錯誤
            frames[next_frame] = page;
            next_frame = (next_frame + 1) % num_frames;
            page_faults++;
            
            print_frames(frames, num_frames);
            printf("\t頁面錯誤");
        } else {
            // 頁面命中
            print_frames(frames, num_frames);
            printf("\t命中");
        }
        
        printf("\n");
    }
    
    printf("\n總頁面錯誤: %d\n", page_faults);
    printf("錯誤率: %.2f%%\n", (float)page_faults / num_pages * 100);
    
    return page_faults;
}

int main() {
    int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
    int num_pages = sizeof(pages) / sizeof(pages[0]);
    
    printf("測試不同框架數的影響：\n");
    
    for (int frames = 2; frames <= 4; frames++) {
        int faults = fifo_page_replacement(pages, num_pages, frames);
        printf("\n");
    }
    
    return 0;
}</code></pre>
                </div>

                <h3>4.2 LRU 頁面置換模擬</h3>

                <div class="code-block">
                    <div class="code-header">
                        <span>lru_page_replacement.c</span>
                        <span>LRU 頁面置換演算法</span>
                    </div>
                    <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define MAX_FRAMES 10

typedef struct {
    int page;
    int last_used;
} Frame;

int find_page(Frame frames[], int num_frames, int page) {
    for (int i = 0; i < num_frames; i++) {
        if (frames[i].page == page) {
            return i;
        }
    }
    return -1;
}

int find_lru(Frame frames[], int num_frames) {
    int lru_index = 0;
    int min_time = frames[0].last_used;
    
    for (int i = 1; i < num_frames; i++) {
        if (frames[i].last_used < min_time) {
            min_time = frames[i].last_used;
            lru_index = i;
        }
    }
    
    return lru_index;
}

void print_frames_lru(Frame frames[], int num_frames) {
    printf("[ ");
    for (int i = 0; i < num_frames; i++) {
        if (frames[i].page == -1) {
            printf("- ");
        } else {
            printf("%d ", frames[i].page);
        }
    }
    printf("]");
}

int lru_page_replacement(int pages[], int num_pages, int num_frames) {
    Frame frames[MAX_FRAMES];
    int page_faults = 0;
    int time = 0;
    
    // 初始化框架
    for (int i = 0; i < num_frames; i++) {
        frames[i].page = -1;
        frames[i].last_used = 0;
    }
    
    printf("\n=== LRU 頁面置換模擬 ===\n");
    printf("框架數: %d\n", num_frames);
    printf("參考字串: ");
    for (int i = 0; i < num_pages; i++) {
        printf("%d ", pages[i]);
    }
    printf("\n\n");
    
    printf("步驟\t頁面\t框架狀態\t\t結果\n");
    printf("----------------------------------------------------\n");
    
    for (int i = 0; i < num_pages; i++) {
        int page = pages[i];
        time++;
        
        printf("%d\t%d\t", i + 1, page);
        
        int frame_idx = find_page(frames, num_frames, page);
        
        if (frame_idx != -1) {
            // 頁面命中
            frames[frame_idx].last_used = time;
            print_frames_lru(frames, num_frames);
            printf("\t命中");
        } else {
            // 頁面錯誤
            page_faults++;
            
            // 找到要置換的框架
            int replace_idx = -1;
            
            // 先檢查是否有空框架
            for (int j = 0; j < num_frames; j++) {
                if (frames[j].page == -1) {
                    replace_idx = j;
                    break;
                }
            }
            
            // 如果沒有空框架，找 LRU
            if (replace_idx == -1) {
                replace_idx = find_lru(frames, num_frames);
            }
            
            frames[replace_idx].page = page;
            frames[replace_idx].last_used = time;
            
            print_frames_lru(frames, num_frames);
            printf("\t頁面錯誤");
        }
        
        printf("\n");
    }
    
    printf("\n總頁面錯誤: %d\n", page_faults);
    printf("錯誤率: %.2f%%\n", (float)page_faults / num_pages * 100);
    
    return page_faults;
}

int main() {
    int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
    int num_pages = sizeof(pages) / sizeof(pages[0]);
    
    lru_page_replacement(pages, num_pages, 3);
    
    return 0;
}</code></pre>
                </div>

                <h3>4.3 Optimal 頁面置換模擬</h3>

                <div class="code-block">
                    <div class="code-header">
                        <span>optimal_page_replacement.c</span>
                        <span>Optimal 頁面置換演算法</span>
                    </div>
                    <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define MAX_FRAMES 10

int find_page_in_frames(int frames[], int num_frames, int page) {
    for (int i = 0; i < num_frames; i++) {
        if (frames[i] == page) {
            return i;
        }
    }
    return -1;
}

int find_optimal_victim(int frames[], int num_frames, 
                        int pages[], int num_pages, int current_pos) {
    int victim = -1;
    int farthest = current_pos;
    
    for (int i = 0; i < num_frames; i++) {
        int page = frames[i];
        int next_use = num_pages; // 假設不再使用
        
        // 找出這個頁面下次使用的位置
        for (int j = current_pos + 1; j < num_pages; j++) {
            if (pages[j] == page) {
                next_use = j;
                break;
            }
        }
        
        // 選擇最晚使用的頁面
        if (next_use > farthest) {
            farthest = next_use;
            victim = i;
        }
    }
    
    return victim;
}

void print_frames_opt(int frames[], int num_frames) {
    printf("[ ");
    for (int i = 0; i < num_frames; i++) {
        if (frames[i] == -1) {
            printf("- ");
        } else {
            printf("%d ", frames[i]);
        }
    }
    printf("]");
}

int optimal_page_replacement(int pages[], int num_pages, int num_frames) {
    int frames[MAX_FRAMES];
    int page_faults = 0;
    
    // 初始化框架
    for (int i = 0; i < num_frames; i++) {
        frames[i] = -1;
    }
    
    printf("\n=== Optimal 頁面置換模擬 ===\n");
    printf("框架數: %d\n", num_frames);
    printf("參考字串: ");
    for (int i = 0; i < num_pages; i++) {
        printf("%d ", pages[i]);
    }
    printf("\n\n");
    
    printf("步驟\t頁面\t框架狀態\t\t結果\n");
    printf("----------------------------------------------------\n");
    
    for (int i = 0; i < num_pages; i++) {
        int page = pages[i];
        
        printf("%d\t%d\t", i + 1, page);
        
        if (find_page_in_frames(frames, num_frames, page) != -1) {
            // 頁面命中
            print_frames_opt(frames, num_frames);
            printf("\t命中");
        } else {
            // 頁面錯誤
            page_faults++;
            
            // 找到要置換的框架
            int replace_idx = -1;
            
            // 先檢查是否有空框架
            for (int j = 0; j < num_frames; j++) {
                if (frames[j] == -1) {
                    replace_idx = j;
                    break;
                }
            }
            
            // 如果沒有空框架，找最優置換
            if (replace_idx == -1) {
                replace_idx = find_optimal_victim(frames, num_frames, 
                                                  pages, num_pages, i);
            }
            
            frames[replace_idx] = page;
            
            print_frames_opt(frames, num_frames);
            printf("\t頁面錯誤");
        }
        
        printf("\n");
    }
    
    printf("\n總頁面錯誤: %d\n", page_faults);
    printf("錯誤率: %.2f%%\n", (float)page_faults / num_pages * 100);
    
    return page_faults;
}

int main() {
    int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
    int num_pages = sizeof(pages) / sizeof(pages[0]);
    
    optimal_page_replacement(pages, num_pages, 3);
    
    return 0;
}</code></pre>
                </div>

                <h3>4.4 演算法效能比較</h3>

                <div class="code-block">
                    <div class="code-header">
                        <span>algorithm_comparison.c</span>
                        <span>比較不同頁面置換演算法</span>
                    </div>
                    <pre><code class="language-c">#include &lt;stdio.h&gt;

// 前面實作的函數聲明
int fifo_page_replacement(int pages[], int num_pages, int num_frames);
int lru_page_replacement(int pages[], int num_pages, int num_frames);
int optimal_page_replacement(int pages[], int num_pages, int num_frames);

void compare_algorithms(int pages[], int num_pages) {
    printf("\n");
    printf("==================================================\n");
    printf("頁面置換演算法效能比較\n");
    printf("==================================================\n\n");
    
    printf("參考字串: ");
    for (int i = 0; i < num_pages; i++) {
        printf("%d ", pages[i]);
    }
    printf("\n總頁數: %d\n\n", num_pages);
    
    printf("框架數\tFIFO\tLRU\tOptimal\n");
    printf("----------------------------------------\n");
    
    for (int frames = 2; frames <= 5; frames++) {
        printf("%d\t", frames);
        
        // FIFO
        int fifo = fifo_page_replacement(pages, num_pages, frames);
        printf("%d\t", fifo);
        
        // LRU
        int lru = lru_page_replacement(pages, num_pages, frames);
        printf("%d\t", lru);
        
        // Optimal
        int opt = optimal_page_replacement(pages, num_pages, frames);
        printf("%d\n", opt);
    }
    
    printf("\n註：數字代表頁面錯誤次數，越小越好\n");
}

int main() {
    int pages1[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
    int num_pages1 = sizeof(pages1) / sizeof(pages1[0]);
    
    compare_algorithms(pages1, num_pages1);
    
    printf("\n\n=== Belady's Anomaly 示範 ===\n");
    printf("某些情況下，增加框架數反而增加頁面錯誤（FIFO）\n\n");
    
    int pages2[] = {1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5};
    int num_pages2 = sizeof(pages2) / sizeof(pages2[0]);
    
    printf("參考字串: ");
    for (int i = 0; i < num_pages2; i++) {
        printf("%d ", pages2[i]);
    }
    printf("\n\n");
    
    for (int frames = 3; frames <= 4; frames++) {
        printf("框架數 %d: ", frames);
        int faults = fifo_page_replacement(pages2, num_pages2, frames);
        printf("\n");
    }
    
    return 0;
}</code></pre>
                </div>

            </section>

            <section id="exercises">
                <div class="exercise-section">
                    <h3>本週作業</h3>

                    <div class="exercise-item">
                        <h4>作業 1：Second Chance 演算法實作</h4>
                        <span class="difficulty difficulty-easy">簡單</span>
                        <p><strong>要求：</strong>實作 Second Chance（時鐘）演算法。</p>
                        <ul>
                            <li>使用參考位元</li>
                            <li>實作循環佇列</li>
                            <li>比較與 FIFO 的效能差異</li>
                            <li>視覺化顯示時鐘指標移動</li>
                        </ul>
                    </div>

                    <div class="exercise-item">
                        <h4>作業 2：工作集追蹤</h4>
                        <span class="difficulty difficulty-medium">中等</span>
                        <p><strong>要求：</strong>實作工作集監控程式。</p>
                        <ul>
                            <li>追蹤給定時間窗口的工作集</li>
                            <li>計算工作集大小隨時間的變化</li>
                            <li>識別何時可能發生顛簸</li>
                            <li>生成工作集大小圖表</li>
                        </ul>
                    </div>

                    <div class="exercise-item">
                        <h4>作業 3：頁面置換模擬器</h4>
                        <span class="difficulty difficulty-medium">中等</span>
                        <p><strong>要求：</strong>建立完整的頁面置換模擬器。</p>
                        <ul>
                            <li>支援多種演算法（FIFO、LRU、Optimal、Second Chance）</li>
                            <li>可從檔案讀取參考字串</li>
                            <li>生成詳細的統計報告</li>
                            <li>視覺化顯示框架狀態變化</li>
                            <li>支援不同框架數的批次測試</li>
                        </ul>
                    </div>

                    <div class="exercise-item">
                        <h4>作業 4：LRU 堆疊實作</h4>
                        <span class="difficulty difficulty-hard">困難</span>
                        <p><strong>要求：</strong>使用堆疊實作 LRU。</p>
                        <ul>
                            <li>維護頁面使用順序堆疊</li>
                            <li>每次存取時更新堆疊</li>
                            <li>比較與計數器實作的效能</li>
                            <li>分析時間和空間複雜度</li>
                            <li>優化堆疊操作</li>
                        </ul>
                    </div>

                    <div class="exercise-item">
                        <h4>作業 5：虛擬記憶體系統模擬</h4>
                        <span class="difficulty difficulty-hard">困難</span>
                        <p><strong>要求：</strong>建立完整的虛擬記憶體系統模擬。</p>
                        <ul>
                            <li>實作頁表和 TLB</li>
                            <li>模擬位址轉換過程</li>
                            <li>處理頁面錯誤</li>
                            <li>實作多種置換演算法</li>
                            <li>計算有效存取時間</li>
                            <li>偵測和報告顛簸</li>
                            <li>支援多個並行行程</li>
                        </ul>
                    </div>

                </div>
            </section>

            <section id="quiz">
                <div class="quiz-section">
                    <h3>本週測驗</h3>

                    <div class="quiz-question">
                        <p><strong>1. 虛擬記憶體的主要優勢不包括？</strong></p>
                        <p>A. 程式可以大於實體記憶體</p>
                        <p>B. 提供行程隔離</p>
                        <p>C. 加快程式執行速度</p>
                        <p>D. 允許更多並行</p>
                        <p><em>答案：C（虛擬記憶體可能因為頁面錯誤而降低速度）</em></p>
                    </div>

                    <div class="quiz-question">
                        <p><strong>2. 哪個頁面置換演算法保證最少的頁面錯誤？</strong></p>
                        <p>A. FIFO</p>
                        <p>B. LRU</p>
                        <p>C. Optimal</p>
                        <p>D. Second Chance</p>
                        <p><em>答案：C</em></p>
                    </div>

                    <div class="quiz-question">
                        <p><strong>3. Belady's Anomaly 是指？</strong></p>
                        <p>A. LRU 效能不佳</p>
                        <p>B. 增加框架數反而增加頁面錯誤</p>
                        <p>C. 頁面錯誤無法避免</p>
                        <p>D. TLB 未命中</p>
                        <p><em>答案：B（主要發生在 FIFO）</em></p>
                    </div>

                    <div class="quiz-question">
                        <p><strong>4. TLB 的作用是？</strong></p>
                        <p>A. 儲存頁面內容</p>
                        <p>B. 快取頁表項目</p>
                        <p>C. 管理記憶體配置</p>
                        <p>D. 處理頁面錯誤</p>
                        <p><em>答案：B</em></p>
                    </div>

                    <div class="quiz-question">
                        <p><strong>5. 顛簸（Thrashing）的主要原因是？</strong></p>
                        <p>A. CPU 太慢</p>
                        <p>B. 硬碟損壞</p>
                        <p>C. 工作集無法完全載入記憶體</p>
                        <p>D. 程式錯誤</p>
                        <p><em>答案：C</em></p>
                    </div>

                    <div class="quiz-question">
                        <p><strong>6. 計算題：假設 TLB 命中率 90%，TLB 存取時間 1ns，記憶體存取時間 100ns，計算有效存取時間</strong></p>
                        <p><em>答案：TLB 命中：1 + 100 = 101ns；TLB 未命中：1 + 100 + 100 = 201ns；有效存取時間 = 0.9 × 101 + 0.1 × 201 = 111 ns</em></p>
                    </div>

                    <div class="quiz-question">
                        <p><strong>7. 問答題：說明為什麼 LRU 比 FIFO 效能更好</strong></p>
                        <p><em>參考答案：LRU 基於局部性原理（Locality of Reference），認為最近使用的頁面很可能在不久的將來再次被使用。因此置換最久未使用的頁面可以保留經常使用的頁面在記憶體中。FIFO 只考慮頁面載入的順序，可能會置換掉仍在頻繁使用的頁面。實驗和理論分析都證明 LRU 的頁面錯誤率通常低於 FIFO，且接近理論最優的 Optimal 演算法。</em></p>
                    </div>

                    <div class="quiz-question">
                        <p><strong>8. 問答題：解釋需求分頁的運作原理及其優勢</strong></p>
                        <p><em>參考答案：需求分頁（Demand Paging）只在需要時才載入頁面到記憶體，而不是在程式啟動時載入所有頁面。運作方式：(1) 程式啟動時不載入任何頁面；(2) 當存取某頁面時檢查頁表；(3) 若頁面不在記憶體中則發生頁面錯誤；(4) 作業系統從磁碟載入該頁面。優勢包括：減少程式啟動時間、降低記憶體需求、可以執行比實體記憶體大的程式、提高記憶體使用效率。但缺點是首次存取會有延遲。</em></p>
                    </div>

                </div>
            </section>

            <div class="navigation">
                <a href="week6.html" class="nav-button">上一週：記憶體管理</a>
                <a href="week8.html" class="nav-button">下一週：期中複習</a>
            </div>

        </div>
    </div>

    <div class="footer">
        <p>作業系統課程 Week 7 © 2026</p>
        <p>建議學習時間：10-12 小時</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });

        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    const offset = 80;
                    const elementPosition = target.getBoundingClientRect().top;
                    const offsetPosition = elementPosition + window.pageYOffset - offset;
                    window.scrollTo({
                        top: offsetPosition,
                        behavior: 'smooth'
                    });
                }
            });
        });
    </script>
</body>
</html>